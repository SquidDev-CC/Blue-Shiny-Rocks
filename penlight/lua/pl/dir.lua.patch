@@ -3427,7039 +3427,3027 @@
 nd%0A%0A
-%0Alocal alien,ffi,ffi_checked,CopyFile,MoveFile,GetLastError,win32_errors,cmd_tmpfile%0A%0Alocal function execute_command(cmd,parms)%0A   if not cmd_tmpfile then cmd_tmpfile = path.tmpname () end%0A   local err = path.is_windows and ' %3E ' or ' 2%3E '%0A    cmd = cmd..' '..parms..err..cmd_tmpfile%0A    local ret = utils.execute(cmd)%0A    if not ret then%0A        return false,(utils.readfile(cmd_tmpfile)%3Agsub('%5Cn(.*)',''))%0A    else%0A        return true%0A    end%0Aend%0A%0Alocal function find_ffi_copyfile ()%0A    if not ffi_checked then%0A        ffi_checked = true%0A        local res%0A        res,alien = pcall(require,'alien')%0A        if not res then%0A            alien = nil%0A            res, ffi = pcall(require,'ffi')%0A        end%0A        if not res then%0A            ffi = nil%0A            return%0A        end%0A    else%0A        return%0A    end%0A    if alien then%0A        -- register the Win32 CopyFile and MoveFile functions%0A        local kernel = alien.load('kernel32.dll')%0A        CopyFile = kernel.CopyFileA%0A        CopyFile%3Atypes%7B'string','string','int',ret='int',abi='stdcall'%7D%0A        MoveFile = kernel.MoveFileA%0A        MoveFile%3Atypes%7B'string','string',ret='int',abi='stdcall'%7D%0A        GetLastError = kernel.GetLastError%0A        GetLastError%3Atypes%7Bret ='int', abi='stdcall'%7D%0A    elseif ffi then%0A        ffi.cdef %5B%5B%0A            int CopyFileA(const char *src, const char *dest, int iovr);%0A            int MoveFileA(const char *src, const char *dest);%0A            int GetLastError();%0A        %5D%5D%0A        CopyFile = ffi.C.CopyFileA%0A        MoveFile = ffi.C.MoveFileA%0A        GetLastError = ffi.C.GetLastError%0A    end%0A    win32_errors = %7B%0A        ERROR_FILE_NOT_FOUND    =         2,%0A        ERROR_PATH_NOT_FOUND    =         3,%0A        ERROR_ACCESS_DENIED    =          5,%0A        ERROR_WRITE_PROTECT    =          19,%0A        ERROR_BAD_UNIT         =          20,%0A        ERROR_NOT_READY        =          21,%0A        ERROR_WRITE_FAULT      =          29,%0A        ERROR_READ_FAULT       =          30,%0A        ERROR_SHARING_VIOLATION =         32,%0A        ERROR_LOCK_VIOLATION    =         33,%0A        ERROR_HANDLE_DISK_FULL  =         39,%0A        ERROR_BAD_NETPATH       =         53,%0A        ERROR_NETWORK_BUSY      =         54,%0A        ERROR_DEV_NOT_EXIST     =         55,%0A        ERROR_FILE_EXISTS       =         80,%0A        ERROR_OPEN_FAILED       =         110,%0A        ERROR_INVALID_NAME      =         123,%0A        ERROR_BAD_PATHNAME      =         161,%0A        ERROR_ALREADY_EXISTS    =         183,%0A    %7D%0Aend%0A%0Alocal function two_arguments (f1,f2)%0A    return quote_argument(f1)..' '..quote_argument(f2)%0Aend%0A%0Alocal function file_op (is_copy,src,dest,flag)%0A    if flag == 1 and path.exists(dest) then%0A        return false,%22cannot overwrite destination%22%0A    end%0A    if is_windows then%0A        -- if we haven't tried to load Alien/LuaJIT FFI before, then do so%0A        find_ffi_copyfile()%0A        -- fallback if there's no Alien, just use DOS commands *shudder*%0A        -- 'rename' involves a copy and then deleting the source.%0A        if not CopyFile then%0A            src = path.normcase(src)%0A            dest = path.normcase(dest)%0A            local cmd = is_copy and 'copy' or 'rename'%0A            local res, err = execute_command('copy',two_arguments(src,dest))%0A            if not res then return false,err end%0A            if not is_copy then%0A                return execute_command('del',quote_argument(src))%0A            end%0A            return true%0A        else%0A            if path.isdir(dest) then%0A                dest = path.join(dest,path.basename(src))%0A            end%0A%09%09%09local ret%0A            if is_copy then ret = CopyFile(src,dest,flag)%0A            else ret = MoveFile(src,dest) end%0A            if ret == 0 then%0A                local err = GetLastError()%0A                for name,value in pairs(win32_errors) do%0A                    if value == err then return false,name end%0A                end%0A                return false,%22Error #%22..err%0A            else return true%0A            end%0A        end%0A    else -- for Unix, just use cp for now%0A        return execute_command(is_copy and 'cp' or 'mv',%0A            two_arguments(src,dest))%0A    end%0Aend%0A%0A--- copy a file.%0A-- @string src source file%0A-- @string dest destination file or directory%0A-- @bool flag true if you want to force the copy (default)%0A-- @treturn bool operation succeeded%0A-- @raise src and dest must be strings%0Afunction dir.copyfile (src,dest,flag)%0A    assert_string(1,src)%0A    assert_string(2,dest)%0A    flag = flag==nil or flag%0A    return file_op(true,src,dest,flag and 0 or 1)%0Aend%0A%0A--- move a file.%0A-- @string src source file%0A-- @string dest destination file or directory%0A-- @treturn bool operation succeeded%0A-- @raise src and dest must be strings%0Afunction dir.movefile (src,dest)%0A    assert_string(1,src)%0A    assert_string(2,dest)%0A    return file_op(false,src,dest,0)%0Aend%0A%0Alocal function _dirfiles(dir,attrib)%0A    local dirs = %7B%7D%0A    local files = %7B%7D%0A    for f in ldir(dir) do%0A        if f ~= '.' and f ~= '..' then%0A            local p = path.join(dir,f)%0A            local mode = attrib(p,'mode')%0A            if mode=='directory' then%0A                append(dirs,f)%0A            else%0A                append(files,f)%0A            end%0A        end%0A    end%0A    return setmetatable(dirs,List),setmetatable(files,List)%0Aend%0A%0A%0Alocal function _walker(root,bottom_up,attrib)%0A    local dirs,files = _dirfiles(root,attrib)%0A    if not bottom_up then yield(root,dirs,files) end%0A    for i,d in ipairs(dirs) do%0A        _walker(root..path.sep..d,bottom_up,attrib)%0A    end%0A    if bottom_up then yield(root,dirs,files) end%0Aend%0A%0A--- return an iterator which walks through a directory tree starting at root.%0A-- The iterator returns (root,dirs,files)%0A-- Note that dirs and files are lists of names (i.e. you must say path.join(root,d)%0A-- to get the actual full path)%0A-- If bottom_up is false (or not present), then the entries at the current level are returned%0A-- before we go deeper. This means that you can modify the returned list of directories before%0A-- continuing.%0A-- This is a clone of os.walk from the Python libraries.%0A-- @string root A starting directory%0A-- @bool bottom_up False if we start listing entries immediately.%0A-- @bool follow_links follow symbolic links%0A-- @return an iterator returning root,dirs,files%0A-- @raise root must be a directory%0Afunction dir.walk(root,bottom_up,follow_links)%0A    assert_dir(1,root)%0A    local attrib%0A    if path.is_windows or not follow_links then%0A        attrib = path.attrib%0A    else%0A        attrib = path.link_attrib%0A    end%0A    return wrap(function () _walker(root,bottom_up,attrib) end)%0Aend%0A%0A--- remove a whole directory tree.%0A-- @string fullpath A directory path%0A-- @return true or nil%0A-- @return error if failed%0A-- @raise fullpath must be a string%0Afunction dir.rmtree(fullpath)%0A    assert_dir(1,fullpath)%0A    if path.islink(fullpath) then return false,'will not follow symlink' end%0A    for root,dirs,files in dir.walk(fullpath,true) do%0A        for i,f in ipairs(files) do%0A            remove(path.join(root,f))%0A        end%0A        rmdir(root)%0A    end
+local function two_arguments (f1,f2)%0A    return quote_argument(f1)..' '..quote_argument(f2)%0Aend%0A%0Alocal function file_op (is_copy,src,dest,flag)%0A    if flag == 1 and path.exists(dest) then%0A        return false,%22cannot overwrite destination%22%0A    end%0A%0A    if is_copy then%0A        fs.copy(src, dest)%0A    else%0A        fs.move(src, dest)%0A    end%0Aend%0A%0A--- copy a file.%0A-- @string src source file%0A-- @string dest destination file or directory%0A-- @bool flag true if you want to force the copy (default)%0A-- @treturn bool operation succeeded%0A-- @raise src and dest must be strings%0Afunction dir.copyfile (src,dest,flag)%0A    assert_string(1,src)%0A    assert_string(2,dest)%0A    flag = flag==nil or flag%0A    return file_op(true,src,dest,flag and 0 or 1)%0Aend%0A%0A--- move a file.%0A-- @string src source file%0A-- @string dest destination file or directory%0A-- @treturn bool operation succeeded%0A-- @raise src and dest must be strings%0Afunction dir.movefile (src,dest)%0A    assert_string(1,src)%0A    assert_string(2,dest)%0A    return file_op(false,src,dest,0)%0Aend%0A%0Alocal function _dirfiles(dir,attrib)%0A    local dirs = %7B%7D%0A    local files = %7B%7D%0A    for f in ldir(dir) do%0A        if f ~= '.' and f ~= '..' then%0A            local p = path.join(dir,f)%0A            local mode = attrib(p,'mode')%0A            if mode=='directory' then%0A                append(dirs,f)%0A            else%0A                append(files,f)%0A            end%0A        end%0A    end%0A    return setmetatable(dirs,List),setmetatable(files,List)%0Aend%0A%0A%0Alocal function _walker(root,bottom_up,attrib)%0A    local dirs,files = _dirfiles(root,attrib)%0A    if not bottom_up then yield(root,dirs,files) end%0A    for i,d in ipairs(dirs) do%0A        _walker(root..path.sep..d,bottom_up,attrib)%0A    end%0A    if bottom_up then yield(root,dirs,files) end%0Aend%0A%0A--- return an iterator which walks through a directory tree starting at root.%0A-- The iterator returns (root,dirs,files)%0A-- Note that dirs and files are lists of names (i.e. you must say path.join(root,d)%0A-- to get the actual full path)%0A-- If bottom_up is false (or not present), then the entries at the current level are returned%0A-- before we go deeper. This means that you can modify the returned list of directories before%0A-- continuing.%0A-- This is a clone of os.walk from the Python libraries.%0A-- @string root A starting directory%0A-- @bool bottom_up False if we start listing entries immediately.%0A-- @bool follow_links follow symbolic links%0A-- @return an iterator returning root,dirs,files%0A-- @raise root must be a directory%0Afunction dir.walk(root,bottom_up,follow_links)%0A    assert_dir(1,root)%0A    local attrib%0A    if path.is_windows or not follow_links then%0A        attrib = path.attrib%0A    else%0A        attrib = path.link_attrib%0A    end%0A    return wrap(function () _walker(root,bottom_up,attrib) end)%0Aend%0A%0A--- remove a whole directory tree.%0A-- @string fullpath A directory path%0A-- @return true or nil%0A-- @return error if failed%0A-- @raise fullpath must be a string%0Afunction dir.rmtree(fullpath)%0A    assert_dir(1,fullpath)%0A    fs.delete(fullpath)
 %0A   
